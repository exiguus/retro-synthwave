{
  "code": "// Understand canvas 2d context 3d animation\n//  original code: https://github.com/victorqribeiro/retroSynthwave\n\n//\n// Three steps are required to get this animation running:\n// 1. init() the matrix system\n//    create a 2d canvas context\n//    create the matrix and points (x, y, z)\n// 2. update() the initialised matrix\n//    change each point (x, y, z)\n//    call show() and request a animation frame by it self recursively\n// 3. show() the changes\n//    draw changes to the canvas\n//\n// update() call show() and then request the animation frame that call update()\n\n// eslint-disable-next-line no-unused-vars\nlet canvas, c, w, h, u, points, offset, gradient\n\n// spacing: X Coordinate spacing\nfunction init({ element, spacing = 40, zOffset = 10 }) {\n  // create canvas element and adjust the element size\n  canvas = document.createElement('canvas')\n  // eslint-disable-next-line no-restricted-globals\n  canvas.width = w = innerWidth\n  // eslint-disable-next-line no-restricted-globals\n  canvas.height = h = innerHeight\n  // get the drawing context on the canvas by creating\n  //  a CanvasRenderingContext2D\n  c = canvas.getContext('2d')\n  // translate the starting points of the coordinate system to the center / middle of the canvas\n  c.translate(w / 2, h / 2)\n  // append the canvas to the html document body\n  element.appendChild(canvas)\n  // Create a Matrix with 30 lines and 60 rows\n  //  by creating a Array with a length of 30 and fill each item with a value of 0\n  //  then map each item and change the value to a Array with a length of 60, each item filled with  a value of 0\n  points = Array(30)\n    .fill(0)\n    .map(_ => Array(60).fill(0))\n  // Set x, y, z values for each coordinate of the Matrix\n  //  by looping each line\n  for (let i = 0; i < points.length; i++) {\n    // and every row\n    for (let j = 0; j < points[0].length; j++) {\n      // difference between the looped raws and the half row count\n      const dist = Math.abs(j - points[0].length / 2)\n      points[i][j] = {\n        x: j * spacing, // x position increased in every loop by a factor of n+1\n        y: Math.random() * -(dist * dist) + 30, // y position randomly lowered in a flat tapered curve\n        z: -i * zOffset, // z position of the column\n      }\n    }\n  }\n\n  // offset for creating squares\n  //  TODO: move to show()\n  offset = (points[0].length * spacing) / 2\n\n  // Create a linear Gradient which has two colors for the sun\n  gradient = c.createLinearGradient(0, -150, 0, 100)\n  gradient.addColorStop(0, 'gold')\n  gradient.addColorStop(1, 'rgb(200, 0, 100)')\n  update(0) // call the animation update\n}\n\n// Performance\n// eslint-disable-next-line no-unused-vars\nlet previousTime\n\n// update current z position and request a animation frame\nfunction update(time) {\n  // the requestAnimationFrame callback has a single argument, a DOMHighResTimeStamp\n  // Check < -300\n  // DEBUG\n  let z300CountSmaller = 0\n  let z300CountBigger = 0\n  // update current z position\n  //  by looping each line\n  for (let i = 0; i < points.length; i++) {\n    let gone = false\n    // and every row\n    for (let j = 0; j < points[0].length; j++) {\n      points[i][j].z -= 0.5\n      // TODO: Find out why -300?\n      if (points[i][j].z < -300) {\n        gone = true\n        // DEBUG\n        // eslint-disable-next-line no-unused-vars\n        z300CountSmaller += 1\n      } else {\n        // DEBUG\n        // eslint-disable-next-line no-unused-vars\n        z300CountBigger += 1\n      }\n    }\n    if (gone) {\n      // remove the last row of the line and copy all other\n      let arr = points.pop()\n      // loop the copy of rows and modify z and y position\n      for (let k = 0; k < arr.length; k++) {\n        // difference between the looped raws and the half row count\n        const dist = Math.abs(k - arr.length / 2)\n        arr[k].z = 0 // TODO: why 0?\n        arr[k].y = Math.random() * -(dist * dist) + 30 // y position randomly lowered in a flat tapered curve\n      }\n      // add the copied line at the beginning of the matrix\n      points.unshift(arr)\n    }\n  }\n  // create the sun and the squares\n  show()\n\n  // DEBUG\n  // console.log(`Smaller: ${z300CountSmaller} / Bigger: ${z300CountBigger}`)\n\n  // perform the animation\n  u = requestAnimationFrame(update)\n\n  // Performance\n  // cancelAnimationFrame(u)\n  // if (previousTime !== time) {\n  //   u = requestAnimationFrame(update)\n  // }\n}\n\nfunction show() {\n  // Clear pixels in the context area and set them transparent black\n  c.clearRect(-w / 2, -h / 2, w, h)\n  // Start draw new in the cleared area\n  c.beginPath()\n  // add a circular arc with a radius of 200 and a startAngel of PI * 2 (begin a new sub-path)\n  c.arc(0, 0, 200, 0, Math.PI * 2)\n  // add a line from the current point to the current sub-path\n  c.closePath()\n  // add shadow and blur and fill the current context\n  c.shadowColor = 'orange'\n  c.shadowBlur = 100\n  c.fillStyle = gradient\n  c.fill()\n  // remove the shadow blur from the context for the upcoming squares\n  c.shadowBlur = 0\n  // create squares and fill / stroke them to the current context\n  //  by looping each line\n  for (let i = 0; i < points.length - 1; i++) {\n    // and each row\n    for (let j = 0; j < points[0].length - 1; j++) {\n      const size = 300 / (300 + points[i][j].z)\n      const nextSize = 300 / (300 + points[i + 1][j].z)\n      // Start draw new (square) in the cleared area\n      c.beginPath()\n      // Begin a new sub-path with smaller x and bigger y position\n      c.moveTo((points[i][j].x - offset) * size, points[i][j].y * size)\n      // Line to the next row and connect them\n      c.lineTo((points[i][j + 1].x - offset) * size, points[i][j + 1].y * size)\n      // Line to the next line and row and connect them\n      c.lineTo(\n        (points[i + 1][j + 1].x - offset) * nextSize,\n        points[i + 1][j + 1].y * nextSize\n      )\n      // Line to the next line and connect them\n      c.lineTo(\n        (points[i + 1][j].x - offset) * nextSize,\n        points[i + 1][j].y * nextSize\n      )\n      // line to the current sub-path to finish the square\n      c.closePath()\n      // fill and stroke the square\n      const color = 300 + points[i][j].z\n      c.fillStyle = `rgba(0, 0, 0, ${-points[i][j].z / 100})`\n      c.strokeStyle = `rgba(${250 - color}, 0, ${50 + color}, ${\n        1 - color / 300\n      })`\n      c.fill()\n      c.stroke()\n    }\n  }\n}\n\nexport default init\n"
}
